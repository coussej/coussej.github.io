<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on coussej</title>
    <link>http://coussej.github.io/post/</link>
    <description>Recent content in Posts on coussej</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Sep 2015 22:23:45 +0000</lastBuildDate>
    <atom:link href="http://coussej.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Listening to generic JSON notifications from PostgreSQL in Go</title>
      <link>http://coussej.github.io/2015/09/15/Listening-to-generic-JSON-notifications-from-PostgreSQL-in-Go/</link>
      <pubDate>Tue, 15 Sep 2015 22:23:45 +0000</pubDate>
      
      <guid>http://coussej.github.io/2015/09/15/Listening-to-generic-JSON-notifications-from-PostgreSQL-in-Go/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s already widely known that PostgreSQL is the leading open source relational database when it comes to features. One of those features is great JSON support, an other is LISTEN/NOTIFY, a nifty pub-sub sytem exclusive to PostgreSQL. When combining these two, you get a good basis for a real-time push notification system. In this post, I will explain how to create a generic trigger function to generate JSON notifications for any table change, and how to listen to them in Go.&lt;/p&gt;

&lt;h2 id=&#34;the-trigger-function:307f08762c85d301a5b8c6b62d39da46&#34;&gt;The trigger function&lt;/h2&gt;

&lt;p&gt;First, we will create the trigger function. The function will notify a channel &lt;em&gt;events&lt;/em&gt; with the table name, the action and the old/new row data, depending on the action. As there are no table specific references, you can use the same trigger on all tables you want notifications from.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE OR REPLACE FUNCTION notify_event() RETURNS TRIGGER AS $$

    DECLARE 
        data json;
        notification json;
    
    BEGIN
    
        -- Convert the old or new row to JSON, based on the kind of action.
        -- Action = DELETE?             -&amp;gt; OLD row
        -- Action = INSERT or UPDATE?   -&amp;gt; NEW row
        IF (TG_OP = &#39;DELETE&#39;) THEN
            data = row_to_json(OLD);
        ELSE
            data = row_to_json(NEW);
        END IF;
        
        -- Contruct the notification as a JSON string.
        notification = json_build_object(
                          &#39;table&#39;,TG_TABLE_NAME,
                          &#39;action&#39;, TG_OP,
                          &#39;data&#39;, data);
        
                        
        -- Execute pg_notify(channel, notification)
        PERFORM pg_notify(&#39;events&#39;,notification::text);
        
        -- Result is ignored since this is an AFTER trigger
        RETURN NULL; 
    END;
    
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the trigger function is created, let&amp;rsquo;s create a sample table&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE products (
  id SERIAL,
  name TEXT,
  quantity FLOAT
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and add a trigger to it. As you can see, we add the trigger for all three actions in only one statement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TRIGGER products_notify_event
AFTER INSERT OR UPDATE OR DELETE ON products
    FOR EACH ROW EXECUTE PROCEDURE notify_event();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;result:307f08762c85d301a5b8c6b62d39da46&#34;&gt;Result&lt;/h2&gt;

&lt;p&gt;Fire up &lt;em&gt;psql&lt;/em&gt; or any other PostgreSQL client and execute the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exampledb=# LISTEN events;
LISTEN
exampledb=# INSERT INTO products (name, quantity)
exampledb-# VALUES (&#39;pen&#39;, 10200);
INSERT 0 1
Asynchronous notification &amp;quot;events&amp;quot; with payload &amp;quot;{&amp;quot;table&amp;quot; : &amp;quot;products&amp;quot;, 
  &amp;quot;action&amp;quot; : &amp;quot;INSERT&amp;quot;, &amp;quot;data&amp;quot; : {&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;pen&amp;quot;,&amp;quot;quantity&amp;quot;:10200}}&amp;quot; 
  received from server process with PID 799.
exampledb=#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et voila, you now get notifications for any action on the table.&lt;/p&gt;

&lt;h2 id=&#34;listening-for-the-notifications-in-go:307f08762c85d301a5b8c6b62d39da46&#34;&gt;Listening for the notifications in Go.&lt;/h2&gt;

&lt;p&gt;Receiving notifications in a terminal doesn&amp;rsquo;t have a lot of real-life value, so the next step would be to capture these events in a server application. In Go, this is fairly easy using the &lt;a href=&#34;https://godoc.org/github.com/lib/pq&#34;&gt;pq&lt;/a&gt; package, which already includes functionality for listening to PostgreSQL notifications.&lt;/p&gt;

&lt;p&gt;The app below is based on the &lt;a href=&#34;http://godoc.org/github.com/lib/pq/listen_example&#34;&gt;sample app&lt;/a&gt; in the pqdocs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;database/sql&amp;quot;
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;github.com/lib/pq&amp;quot;
)

func waitForNotification(l *pq.Listener) {
	for {
		select {
		case n := &amp;lt;-l.Notify:
			fmt.Println(&amp;quot;Received data from channel [&amp;quot;, n.Channel, &amp;quot;] :&amp;quot;)
			// Prepare notification payload for pretty print
			var prettyJSON bytes.Buffer
			err := json.Indent(&amp;amp;prettyJSON, []byte(n.Extra), &amp;quot;&amp;quot;, &amp;quot;\t&amp;quot;)
			if err != nil {
				fmt.Println(&amp;quot;Error processing JSON: &amp;quot;, err)
				return
			}
			fmt.Println(string(prettyJSON.Bytes()))
			return
		case &amp;lt;-time.After(90 * time.Second):
			fmt.Println(&amp;quot;Received no events for 90 seconds, checking connection&amp;quot;)
			go func() {
				l.Ping()
			}()
			return
		}
	}
}

func main() {
	var conninfo string = &amp;quot;dbname=exampledb user=webapp password=webapp&amp;quot;

	_, err := sql.Open(&amp;quot;postgres&amp;quot;, conninfo)
	if err != nil {
		panic(err)
	}

	reportProblem := func(ev pq.ListenerEventType, err error) {
		if err != nil {
			fmt.Println(err.Error())
		}
	}

	listener := pq.NewListener(conninfo, 10*time.Second, time.Minute, reportProblem)
	err = listener.Listen(&amp;quot;events&amp;quot;)
	if err != nil {
		panic(err)
	}

	fmt.Println(&amp;quot;Start monitoring PostgreSQL...&amp;quot;)
	for {
		waitForNotification(listener)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, run the app and make a change on the products table. You will see the notifications are being handled by the app:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Received data from channel [ events ] :
{
        &amp;quot;table&amp;quot;: &amp;quot;products&amp;quot;,
        &amp;quot;action&amp;quot;: &amp;quot;INSERT&amp;quot;,
        &amp;quot;data&amp;quot;: {
                &amp;quot;id&amp;quot;: 1,
                &amp;quot;name&amp;quot;: &amp;quot;pen&amp;quot;,
                &amp;quot;quantity&amp;quot;: 10200
        }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;what-s-next:307f08762c85d301a5b8c6b62d39da46&#34;&gt;What&amp;rsquo;s next?&lt;/h2&gt;

&lt;p&gt;Of course, this example app isn&amp;rsquo;t going to be of much use in real life. A better example would be to create a Websocket http handler that notifies any subscribed clients of the changes, so you can forward the database updates in real time to the clients. I&amp;rsquo;ll take this up in a next post.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>